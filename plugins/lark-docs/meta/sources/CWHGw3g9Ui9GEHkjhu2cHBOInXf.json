{
  "creator": "ou_8554528ee6e965bad56710acde1c7847",
  "has_child": false,
  "node_create_time": "1689055561",
  "node_token": "CWHGw3g9Ui9GEHkjhu2cHBOInXf",
  "node_type": "origin",
  "obj_create_time": "1689055561",
  "obj_edit_time": "1689750347",
  "obj_token": "OZtZdBS64olLnixiz97cDfg1nne",
  "obj_type": "docx",
  "origin_node_token": "CWHGw3g9Ui9GEHkjhu2cHBOInXf",
  "origin_space_id": "7167193056431783939",
  "owner": "ou_8554528ee6e965bad56710acde1c7847",
  "parent_node_token": "L4qDwChWLi1Vy6kbt30cd7W4ntC",
  "space_id": "7167193056431783939",
  "title": "ANN Search Explained",
  "slug": "ann-search-explained",
  "blocks": {
    "items": [
      {
        "block_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "block_type": 1,
        "children": [
          "GPXtdHkJ9oahqSxNYqdcgEe6nTd",
          "O0b2dQr2oosS8XxnwPQcVENVnZg",
          "AYTvdpv3moBydTxDGoscvuiCn0d",
          "I27sdgHLdowWSFxVRBtcC4IOnjc",
          "DlICdkyTCoPf9XxzncNc3cOmn7g",
          "JP8ld0zlpo3ogexqpJJcO0svnk5",
          "IUhmdCrvooT0tOxr0GscYdkRnOl",
          "Wwq3dfzNzoA7UCxJ2kYcZWlendc",
          "RmzddM1euoeasexl2e3c2Dc6nin",
          "Trjrd1wb1o49C9x4fh8chTlCnth",
          "OABJdK9Tlo6jbBxU7S1cGn4lnFj",
          "G0yVdC8hdoIDeFxcSeccB7c2nic",
          "KnCidXceGozW1oxNRFicVn7VnHL",
          "YgdqdIX5CoZZ9tx38RFcEX6CnUb",
          "FGV2dBYaJoBU0KxVgkNcJ2K0npc",
          "NvUKd7WBmoMmUCxEnDVcW39pnBb",
          "BRljdqSArorrJixoIhOcs2WhnBL",
          "Q22QdxTAwolNoaxKHcecweaJnWb",
          "W8SUdiQH6ocdIQxhVruczp4onje",
          "O0NKdpR6iodIy4xPvONcYKbantb",
          "WFC2donXcor6I4xzpzXcFUhHnGh",
          "NVV7dVeRAoNbG3x1qkbcpbMKnBu",
          "J9mGdp6YqofVr9xTR9AcPa19ndf",
          "RGUIdhRiIoVXMHxatzpccs05n5N",
          "OF77dIIz5ojuwqxxFFYcg0EDnTe",
          "UxildAQMIoQdOax6pWbcTo3an8f",
          "ZgVAdBV7UoNPbFxq9mccgDSOnEg",
          "Dsh6duQRkosTvVxjJDScPLgSnf3",
          "IF6ndvxlYopLMQxz78ecYkUAneX",
          "EIVwdHkeAohJXbxUWW2cbAcbnyg",
          "G8bxdBOUoo2Mvuxse9OcQ4vOnsb",
          "XqbjdndMqowp5AxaVS7c7QKyn97",
          "BS2mdJdtNo9HAdxoRHocrFkJn0d",
          "D6V5dABDQoJ1knxD2CzcABtEn8W",
          "OAIvdtMA4orD9Xx6AtUckoUknbc",
          "DoNnd5ZE0oEslXx9gENcH0ifnog",
          "OMvedDEZRo6LJjx9LtfcdyADn2b",
          "T0mUdSMDCoWQLvx6BEAc8vaYn1I"
        ],
        "page": {
          "elements": [
            {
              "text_run": {
                "content": "ANN Search Explained",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1
          }
        },
        "parent_id": ""
      },
      {
        "block_id": "GPXtdHkJ9oahqSxNYqdcgEe6nTd",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "A k-nearest neighbor (kNN) search finds the k-nearest vectors to a ",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": "query",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": " vector. Specifically, it compares a query vector to every vector in a vector space until k exact matches appear. Although kNN searches guarantee perfect accuracy, they are time-consuming, especially for large datasets comprising high-dimensional vectors.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "O0b2dQr2oosS8XxnwPQcVENVnZg",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "In contrast, approximate nearest neighbor (ANN) searches require building an index beforehand. Various indexing algorithms demonstrate trade-offs among search speed, memory usage, and accuracy. Generally, two paths are available to implement these algorithms: narrowing the search scope and decomposing high-dimensional vector spaces into low-dimensional subspaces.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "AYTvdpv3moBydTxDGoscvuiCn0d",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Narrowing the search scope can reduce search time by selecting only a subset of possible candidates for comparison with the ",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": "query",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": " vector. This avoids irrelevant vectors. To determine whether a vector is in the subset, an index structure is needed to sort the vectors.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "I27sdgHLdowWSFxVRBtcC4IOnjc",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "There are generally three ideas available for forming the index structure: graphs, trees, and hashes.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "DlICdkyTCoPf9XxzncNc3cOmn7g",
        "block_type": 4,
        "heading2": {
          "elements": [
            {
              "text_run": {
                "content": "HNSW: A graph-based indexing algorithm",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "JP8ld0zlpo3ogexqpJJcO0svnk5",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Hierarchical Navigable Small World (HNSW) indexes a vector space by creating a hierarchical proximity graph. Specifically, HNSW draws proximity links (or edges) between vectors (or vertices) on each layer to form a single-layer proximity graph and stacks them up to form the hierarchical graph. The bottom layer holds all vectors and their proximity links. As the layer goes up, only a smaller set of vectors and proximity links remains.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "IUhmdCrvooT0tOxr0GscYdkRnOl",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Once the hierarchical proximity graph is created, the search goes as follows:",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "Wwq3dfzNzoA7UCxJ2kYcZWlendc",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Find a vector as the entry point on the top layer.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "RmzddM1euoeasexl2e3c2Dc6nin",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Move gradually to the nearest vector along the available proximity links.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "Trjrd1wb1o49C9x4fh8chTlCnth",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Once you determine the nearest vector at the top layer, use the same vector at a lower layer as the entry point to find its nearest neighbor at that layer.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "OABJdK9Tlo6jbBxU7S1cGn4lnFj",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Repeat the preceding steps until you find the nearest vector at the bottom layer.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "G0yVdC8hdoIDeFxcSeccB7c2nic",
        "block_type": 26,
        "iframe": {
          "component": {
            "iframe_type": 8,
            "url": "https%3A%2F%2Fwww.figma.com%2Ffile%2FRb9z8tsmYYdqdultiKx7kT%2FZilliz-Diagrams%3Ftype%3Ddesign%26node-id%3D5920-1662%26t%3DawbuihfOcf5CCViU-4"
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "KnCidXceGozW1oxNRFicVn7VnHL",
        "block_type": 4,
        "heading2": {
          "elements": [
            {
              "text_run": {
                "content": "ANNOY: A tree-based indexing algorithm",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "YgdqdIX5CoZZ9tx38RFcEX6CnUb",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Approximate Nearest Neighbor Oh Yeah (ANNOY) indexes a vector space by building a forest of binary trees. For each tree, ANNOY uses the hyperplane equidistant from two random vectors in the vector space to split the space into two subspaces. This process is repeated for each subspace until there are at most K items in each subspace.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "FGV2dBYaJoBU0KxVgkNcJ2K0npc",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "A single tree may not suffice because some of the nearest neighbors may be outside of the found leaf polygon. ANNOY suggests building a forest of binary trees and choosing the K nearest neighbors from the union of the found leaf polygons.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "NvUKd7WBmoMmUCxEnDVcW39pnBb",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "The following is the tree that records the hyperplane split process.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "BRljdqSArorrJixoIhOcs2WhnBL",
        "block_type": 26,
        "iframe": {
          "component": {
            "iframe_type": 8,
            "url": "https%3A%2F%2Fwww.figma.com%2Ffile%2FRb9z8tsmYYdqdultiKx7kT%2FZilliz-Diagrams%3Ftype%3Ddesign%26node-id%3D5920-1731%26t%3DNHjK1iINqCVGGgmc-4"
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "Q22QdxTAwolNoaxKHcecweaJnWb",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Once the forest of binary trees is ready, the search goes as follows:",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "W8SUdiQH6ocdIQxhVruczp4onje",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Start a priority queue and insert the root of each tree in the queue.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "O0NKdpR6iodIy4xPvONcYKbantb",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Use the priority queue to search in these trees until K candidates are found.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "WFC2donXcor6I4xzpzXcFUhHnGh",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Remove any duplicate candidates.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "NVV7dVeRAoNbG3x1qkbcpbMKnBu",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Compute the distances to the candidates.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "J9mGdp6YqofVr9xTR9AcPa19ndf",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Sort the candidates by distance and list the top K results.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "RGUIdhRiIoVXMHxatzpccs05n5N",
        "block_type": 4,
        "heading2": {
          "elements": [
            {
              "text_run": {
                "content": "LSH: A hash-based ANN indexing algorithm",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "OF77dIIz5ojuwqxxFFYcg0EDnTe",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Locality-sensitive hashing (LSH) indexes a vector space by mapping data pieces of any length to fixed-length values as hashes using various hash functions, gathering these hashes into hash buckets, and tagging vectors that have been hashed to the same value at least once as candidate pairs.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "UxildAQMIoQdOax6pWbcTo3an8f",
        "block_type": 26,
        "iframe": {
          "component": {
            "iframe_type": 8,
            "url": "https%3A%2F%2Fwww.figma.com%2Ffile%2FRb9z8tsmYYdqdultiKx7kT%2FZilliz-Diagrams%3Ftype%3Ddesign%26node-id%3D5926-1662%26t%3DWN2T9DLm4eZtzf5h-4"
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "ZgVAdBV7UoNPbFxq9mccgDSOnEg",
        "block_type": 4,
        "heading2": {
          "elements": [
            {
              "text_run": {
                "content": "DiskANN: ANN search on disk based on Vamana graphs",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "Dsh6duQRkosTvVxjJDScPLgSnf3",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Unlike HNSW that builds a hierarchical graph for layered searches, Vamanaâ€™s indexing process is relatively simple:",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "IF6ndvxlYopLMQxz78ecYkUAneX",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Initialize a random graph;",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "EIVwdHkeAohJXbxUWW2cbAcbnyg",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Find the navigation point by first locating the global centroid and determining the closest point. Use a global comparison to minimize the average search radius.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "G8bxdBOUoo2Mvuxse9OcQ4vOnsb",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Perform Approximate Nearest Neighbor Search with the initialized random neighbor graph and search starting point from step 2. Use all points on the search path as candidate neighbor sets and apply the edge trimming strategy with alpha = 1 to reduce the search radius.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "XqbjdndMqowp5AxaVS7c7QKyn97",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Repeat step 3 with adjusted alpha > 1 (1.2 recommended in the paper) to improve graph quality and recall rate.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "BS2mdJdtNo9HAdxoRHocrFkJn0d",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "Once the index is ready, the search goes as follows:",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      },
      {
        "block_id": "D6V5dABDQoJ1knxD2CzcABtEn8W",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Load relevant data, including ",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": "query",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": " set, PQ center point data, codebook data, search starting point, and index meta.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "OAIvdtMA4orD9Xx6AtUckoUknbc",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Use the indexed data set to perform cached_beam_search, count the access times of each point, and cache the num_nodes_to_cache points with the highest access frequency.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "DoNnd5ZE0oEslXx9gENcH0ifnog",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "WARMUP operation is performed by default using the sample data set to perform a cached_beam_search.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "OMvedDEZRo6LJjx9LtfcdyADn2b",
        "block_type": 13,
        "ordered": {
          "elements": [
            {
              "text_run": {
                "content": "Perform cached_beam_search with the ",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": "query",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": " set for each given parameter L, and output statistics such as recall rate and ",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": "QPS",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": ". Warmup and hotspot data statistics are not included in query time.",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        },
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne"
      },
      {
        "block_id": "T0mUdSMDCoWQLvx6BEAc8vaYn1I",
        "block_type": 2,
        "parent_id": "OZtZdBS64olLnixiz97cDfg1nne",
        "text": {
          "elements": [
            {
              "text_run": {
                "content": "For details, refer to ",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": "DiskANN, A Disk-based ANNS Solution with High Recall and High QPS on Billion-scale Dataset",
                "text_element_style": {
                  "bold": false,
                  "inline_code": false,
                  "italic": false,
                  "link": {
                    "url": "https%3A%2F%2Fmilvus.io%2Fblog%2F2021-09-24-diskann.md"
                  },
                  "strikethrough": false,
                  "underline": false
                }
              }
            },
            {
              "text_run": {
                "content": ".",
                "text_element_style": {
                  "bold": true,
                  "inline_code": false,
                  "italic": false,
                  "strikethrough": false,
                  "underline": false
                }
              }
            }
          ],
          "style": {
            "align": 1,
            "folded": false
          }
        }
      }
    ],
    "counts": 39
  }
}