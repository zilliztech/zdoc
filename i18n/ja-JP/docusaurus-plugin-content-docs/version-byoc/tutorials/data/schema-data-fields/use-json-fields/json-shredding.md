---
title: "JSONシャレディング | BYOC"
slug: /json-shredding
sidebar_label: "JSONシャレディング"
beta: PUBLIC
added_since: FALSE
last_modified: FALSE
deprecate_since: FALSE
notebook: FALSE
description: "JSONシャレディングは、従来の行ベースストレージを最適化された列ベースストレージに変換することでJSONクエリを高速化します。データモデリングのためのJSONの柔軟性を維持しながら、Zilliz Cloudは舞台裏で列ベースの最適化を実行し、アクセスおよびクエリ効率を大幅に向上させます。 | BYOC"
type: origin
token: Dh8MwFuZliYf9Wkhee3c1FhUnGd
sidebar_position: 3
keywords:
  - zilliz
  - ベクトルデータベース
  - クラウド
  - コレクション
  - スキーマ
  - jsonフィールド
  - jsonシャレディング
  - ニューラルネットワーク
  - ディープラーニング
  - 知識ベース
  - 自然言語処理

---

import Admonition from '@theme/Admonition';


# JSONシャレディング

JSONシャレディングは、従来の行ベースストレージを最適化された列ベースストレージに変換することでJSONクエリを高速化します。データモデリングのためのJSONの柔軟性を維持しながら、Zilliz Cloudは舞台裏で列ベースの最適化を実行し、アクセスおよびクエリ効率を大幅に向上させます。

JSONシャレディングは、ほとんどのJSONクエリシナリオで効果的です。パフォーマンスの利点は以下の場合により顕著になります。

- **より大きく複雑なJSONドキュメント** - ドキュメントサイズが大きくなるにつれてパフォーマンス向上が大きくなります

- **読み取り中心のワークロード** - JSONキーでの頻繁なフィルタリング、ソート、検索

- **混合クエリパターン** - 異なるJSONキーにわたるクエリは、ハイブリッドストレージアプローチの恩恵を受けます

## 動作原理\{#how-it-works}

JSONシャレディングプロセスは、高速な検索にデータを最適化するために3つの明確な段階で行われます。

### フェーズ1: インジェストとキー分類\{#phase-1-ingestion-and-key-classification}

新しいJSONドキュメントが書き込まれる際、Zilliz Cloudはそれらを継続的にサンプリング・分析し、各JSONキーの統計情報を構築します。この分析には、キーの出現率と型の安定性（ドキュメント間でデータ型が一貫しているかどうか）が含まれます。

これらの統計情報に基づき、JSONキーは最適なストレージ用に以下のカテゴリに分類されます。

#### JSONキーのカテゴリ\{#categories-of-json-keys}

<table>
   <tr>
     <th><p>キー型</p></th>
     <th><p>説明</p></th>
   </tr>
   <tr>
     <td><p>型付きキー</p></td>
     <td><p>ほとんどのドキュメントに存在し、常に同じデータ型を持つキー（例：すべて整数またはすべて文字列）。</p></td>
   </tr>
   <tr>
     <td><p>動的キー</p></td>
     <td><p>頻繁に出現するが、混合データ型を持つキー（例：場合によっては文字列、場合によっては整数）。</p></td>
   </tr>
   <tr>
     <td><p>共有キー</p></td>
     <td><p>出現頻度が低いかネストされたキーで、設定可能な頻度しきい値よりも低い。</p></td>
   </tr>
</table>

#### 分類例\{#example-classification}

以下のJSONキーを含むサンプルJSONデータを考えてみましょう。

```json
{"a": 10, "b": "str1", "f": 1}
{"a": 20, "b": "str2", "f": 2}
{"a": 30, "b": "str3", "f": 3}
{"a": 40, "b": 1, "f": 4}       // bは混合型になる
{"a": 50, "b": 2, "e": "rare"}  // eは出現頻度が低い
```

このデータに基づき、キーは以下のように分類されます。

- **型付きキー**: `a` および `f`（常に整数）

- **動的キー**: `b`（混合文字列/整数）

- **共有キー**: `e`（出現頻度が低いキー）

### フェーズ2: ストレージ最適化\{#phase-2-storage-optimization}

[フェーズ1](./json-shredding#phase-1-ingestion-and-key-classification)の分類によりストレージレイアウトが決定されます。Zilliz Cloudはクエリに最適化された列形式を使用します。

![FcrMw6pY8h2jE8b2PQ3cp4fTnch](/img/FcrMw6pY8h2jE8b2PQ3cp4fTnch.png)

- **シャレッド列**: **型付き**および**動的**キーについては、専用の列にデータが書き込まれます。この列ベースストレージにより、クエリ時の高速・直接スキャンが可能となり、Zilliz Cloudはドキュメント全体を処理することなく、指定されたキーに必要なデータのみを読み取ることができます。

- **共有列**: すべての**共有キー**は、単一のコンパクトなバイナリJSON列に一緒に保存されます。この列には共有キーの**逆インデックス**が構築されます。このインデックスは、指定されたキーを含む行だけに検索範囲を効果的に絞り込むことで、Zilliz Cloudがデータを迅速にプルーニングできるようにすることにより、低頻度キーのクエリを高速化する上で不可欠です。

### フェーズ3: クエリ実行\{#phase-3-query-execution}

最終フェーズでは、最適化されたストレージレイアウトを活用して、各クエリ述語に対する最速パスを賢く選択します。

- **高速パス**: 型付き/動的キーのクエリ（例：`json['a'] < 100`）は、専用の列に直接アクセスします

- **最適化パス**: 共有キーのクエリ（例：`json['e'] = 'rare'`）は、逆インデックスを使用して関連ドキュメントを迅速に特定します

## パフォーマンスベンチマーク\{#performance-benchmarks}

私たちのテストでは、異なるJSONキー型およびクエリパターンにわたる顕著なパフォーマンス向上が示されました。

### テスト環境および手法\{#test-environment-and-methodology}

- **ハードウェア**: 1コア/8GBクラスター

- **データセット**: [JSONBench](https://github.com/ClickHouse/JSONBench.git) の100万ドキュメント

- **平均ドキュメントサイズ**: 478.89バイト

- **テスト期間**: 100秒間のQPSおよびレイテンシを測定

### 結果：型付きキー\{#results-typed-keys}

このテストでは、ほとんどのドキュメントに存在するキーをクエリした際のパフォーマンスを測定しました。

<table>
   <tr>
     <th><p>クエリ式</p></th>
     <th><p>キー値の型</p></th>
     <th><p>シャレディングなしのQPS</p></th>
     <th><p>シャレディングありのQPS</p></th>
     <th><p>パフォーマンス向上</p></th>
   </tr>
   <tr>
     <td><p><code>json['time_us'] &gt; 0</code></p></td>
     <td><p>整数</p></td>
     <td><p>8.69</p></td>
     <td><p>287.50</p></td>
     <td><p>33倍</p></td>
   </tr>
   <tr>
     <td><p><code>json['kind'] == 'commit'</code></p></td>
     <td><p>文字列</p></td>
     <td><p>8.42</p></td>
     <td><p>126.1</p></td>
     <td><p>14.9倍</p></td>
   </tr>
</table>

### 結果：共有キー\{#results-shared-keys}

このテストでは、"共有"カテゴリに分類されるスパース・ネストされたキーをクエリすることに焦点を当てました。

<table>
   <tr>
     <th><p>クエリ式</p></th>
     <th><p>キー値の型</p></th>
     <th><p>シャレディングなしのQPS</p></th>
     <th><p>シャレディングありのQPS</p></th>
     <th><p>パフォーマンス向上</p></th>
   </tr>
   <tr>
     <td><p><code>json['identity']['seq'] &gt; 0</code></p></td>
     <td><p>ネストされた整数</p></td>
     <td><p>4.33</p></td>
     <td><p>385</p></td>
     <td><p>88.9倍</p></td>
   </tr>
   <tr>
     <td><p><code>json['identity']['did'] == 'xxxxx'</code></p></td>
     <td><p>ネストされた文字列</p></td>
     <td><p>7.6</p></td>
     <td><p>352</p></td>
     <td><p>46.3倍</p></td>
   </tr>
</table>

### 主な洞察\{#key-insights}

- **共有キークエリ**は最も劇的な改善（最大89倍高速）を示します

- **型付きキークエリ**は15-30倍の安定したパフォーマンス向上を提供します

- **すべてのクエリ型**はパフォーマンス低下なしにJSONシャレディングの恩恵を受けます

## よくある質問\{#faq}

- **JSONシャレディングとJSONインデクシングの選択方法は？**

    - **JSONシャレディング**は、ドキュメント内に頻繁に出現するキーに理想的であり、特に複雑なJSON構造に適しています。列ベースストレージと逆インデックスの利点を組み合わせており、多くの異なるキーをクエリする読み取り中心のシナリオに適しています。ただし、非常に小さなJSONドキュメントには推奨されません。パフォーマンス向上は最小限です。JSONドキュメントの総サイズに対するキー値の割合が小さければ小さいほど、シャレディングによるパフォーマンス最適化はより良くなります。

    - **JSONインデクシング**は、特定のキーに基づくクエリのターゲット最適化に適しており、ストレージオーバーヘッドが低くなります。シンプルなJSON構造に適しています。JSONシャレディングは配列内のキーに対するクエリをカバーしていないため、それらを高速化するにはJSONインデックスが必要であることに注意してください。

    詳細は[JSONフィールド概要](./json-field-overview#next-accelerate-json-queries)を参照してください。
