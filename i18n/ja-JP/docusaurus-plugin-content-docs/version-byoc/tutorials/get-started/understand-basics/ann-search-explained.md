---
title: "ANN 検索の説明 | BYOC"
slug: /ann-search-explained
sidebar_label: "ANN 検索の説明"
beta: FALSE
added_since: FALSE
last_modified: FALSE
deprecate_since: FALSE
notebook: FALSE
description: "k近傍 (kNN) 検索は、クエリベクトルに最も近い k 個のベクトルを見つけます。具体的には、クエリベクトルをベクトル空間のすべてのベクトルと比較し、k 個の正確な一致が見つかるまで続けます。kNN 検索は完全な精度を保証しますが、特に高次元ベクトルを含む大規模データセットでは時間がかかります。 | BYOC"
type: origin
token: CWHGw3g9Ui9GEHkjhu2cHBOInXf
sidebar_position: 2
keywords:
  - zilliz
  - vector database
  - cloud
  - ann search
  - milvus
  - natural language processing
  - AI chatbots
  - cosine distance
  - what is a vector database

---

import Admonition from '@theme/Admonition';


# ANN 検索の説明

k近傍 (kNN) 検索は、クエリベクトルに最も近い k 個のベクトルを見つけます。具体的には、クエリベクトルをベクトル空間のすべてのベクトルと比較し、k 個の正確な一致が見つかるまで続けます。kNN 検索は完全な精度を保証しますが、特に高次元ベクトルを含む大規模データセットでは時間がかかります。

一方、近似最近傍 (ANN) 検索では、事前にインデックスを構築する必要があります。さまざまなインデックスアルゴリズムは、検索速度、メモリ使用量、および精度の間でトレードオフを示します。一般的に、これらのアルゴリズムを実装するには2つの方法があります：検索範囲を狭めることと、高次元ベクトル空間を低次元サブ空間に分解することです。

検索範囲を狭めることで、クエリベクトルと比較する可能性のある候補のサブセットのみを選択することで検索時間を短縮できます。これにより、不必要なベクトルを回避します。ベクトルがサブセット内にあるかどうかを判断するには、ベクトルを並べ替えるインデックス構造が必要です。

インデックス構造を形成するための一般的なアイデアは、グラフ、ツリー、およびハッシュの3つがあります。

## HNSW：グラフベースのインデックスアルゴリズム\{#hnsw-a-graph-based-indexing-algorithm}

階層的ナビゲーション可能なスモールワールド (HNSW) は、階層的な近接グラフを作成することでベクトル空間にインデックスを付与します。具体的には、HNSW は各レイヤーのベクトル（または頂点）間に近接リンク（またはエッジ）を描画して単層の近接グラフを形成し、それらを積み重ねて階層的なグラフを形成します。最下層にはすべてのベクトルとそれらの近接リンクが含まれます。レイヤーが上に進むにつれて、少数のベクトルと近接リンクのみが残ります。

階層的な近接グラフが作成されると、検索は以下のようになります：

1. 最上層でエントリポイントとなるベクトルを見つけます。

1. 利用可能な近接リンクに沿って徐々に最も近いベクトルに移動します。

1. 最上層で最も近いベクトルを決定した後、下位レイヤーの同じベクトルをエントリポイントとして使用して、そのレイヤーでの最も近い近傍を見つけます。

1. 最下層での最も近いベクトルが見つかるまで、上記の手順を繰り返します。

![hnsw-explained](/img/hnsw-explained.png)

## LSH：ハッシュベースの ANN インデックスアルゴリズム\{#lsh-a-hash-based-ann-indexing-algorithm}

ローカリティセンシティブハッシング (LSH) は、任意の長さのデータをさまざまなハッシュ関数を使用して固定長の値（ハッシュ）にマッピングし、これらのハッシュをハッシュバケットに収集し、少なくとも一度同じ値にハッシュされたベクトルを候補ペアとしてマークすることで、ベクトル空間にインデックスを付与します。

![locality_sensitive_hashing](/img/locality_sensitive_hashing.png)

## DiskANN：Vamana グラフに基づくディスクベースの ANN 検索\{#diskann-ann-search-on-disk-based-on-vamana-graphs}

階層グラフを構築して層別検索を行う HNSW とは異なり、Vamana のインデックスプロセスは比較的単純です：

1. ランダムグラフを初期化する。

1. グローバル重心を見つけて最も近い点を決定することでナビゲーションポイントを検索します。グローバル比較を使用して平均検索半径を最小限に抑えます。

1. 初期化されたランダム近傍グラフと手順2の検索開始点を使用して近似最近傍検索を実行します。検索パス上のすべての点を候補近傍セットとして使用し、alpha = 1 でエッジトリミング戦略を適用して検索半径を削減します。

1. グラフの品質と再現率を向上させるために、調整された alpha > 1（論文では1.2が推奨）で手順3を繰り返します。

インデックスが準備できたら、検索は以下のようになります：

1. クエリセット、PQ 中心点データ、コードブックデータ、検索開始点、およびインデックスメタを含む関連データをロードします。

1. インデックス化されたデータセットを使用して cached_beam_search を実行し、各点のアクセス回数をカウントし、最もアクセス頻度が高い num_nodes_to_cache 点をキャッシュします。

1. サンプルデータセットを使用して cached_beam_search を実行することにより、デフォルトで WARMUP 操作が実行されます。

1. 各与えられたパラメータ L に対してクエリセットで cached_beam_search を実行し、再現率や QPS などの統計情報を出力します。ウォームアップおよびホットスポットデータの統計はクエリ時間には含まれません。

詳細については、[DiskANN、10億スケールデータセットで高再現率と高QPSを実現したディスクベースのANNSソリューション](https://milvus.io/blog/2021-09-24-diskann.md)を参照してください。